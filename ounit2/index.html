<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ounit2.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ ounit2</nav><nav class="toc"><ul><li><a href="#ounit:-xunit-testing-framework-for-ocaml">OUnit: xUnit testing framework for OCaml</a><ul><li><a href="#what-is-unit-testing?">What is unit Testing?</a></li><li><a href="#getting-started">Getting Started</a></li><li><a href="#extra-features">Extra features</a></li><li><a href="#advanced-usage">Advanced usage</a><ul><li><a href="#error-reporting">Error reporting</a></li><li><a href="#command-line-arguments">Command-line arguments</a></li><li><a href="#skip-and-todo-tests">Skip and todo tests</a></li><li><a href="#ounit2.threads">OUnit2.Threads</a></li><li><a href="#effective-ounit">Effective OUnit</a></li><li><a href="#ounit2.advanced">OUnit2.Advanced</a></li></ul></li></ul></li></ul></nav></header><h2 id="ounit:-xunit-testing-framework-for-ocaml"><a href="#ounit:-xunit-testing-framework-for-ocaml" class="anchor"></a>OUnit: xUnit testing framework for OCaml</h2><h3 id="what-is-unit-testing?"><a href="#what-is-unit-testing?" class="anchor"></a>What is unit Testing?</h3><p>A test-oriented methodology for software development is most effective when tests are easy to create, change, and execute. The JUnit tool pioneered test-first development in Java. OUnit is an adaptation of JUnit to OCaml.</p><p>With OUnit, as with JUnit, you can easily create tests, name them, group them into suites, and execute them, with the framework checking the results automatically.</p><ul class="modules"><li><a href="OUnit2/index.html"><code>OUnit2</code></a></li><li><a href="OUnit/index.html"><code>OUnit</code></a></li></ul><h3 id="getting-started"><a href="#getting-started" class="anchor"></a>Getting Started</h3><p>The basic principle of a OUnit test suite is to have a <i>test.ml</i> file which will contain the tests, and an OCaml module under test, here named <i>foo.ml</i>.</p><p>File <i>foo.ml</i>:</p><pre><code class="ml">(* The functions we wish to test *)
let unity x = x;;
let funix ()= 0;;
let fgeneric () = failwith &quot;Not implemented&quot;;;</code></pre><p>The main point of a test is to check that the function under test has the expected behavior. You check the behavior using assert functions. The simplest one is <a href="OUnit2/index.html#val-assert_equal"><code>OUnit2.assert_equal</code></a>. This function compares the result of the function under test with an expected result.</p><p>Some useful functions include:</p><ul><li><a href="OUnit2/index.html#val-assert_equal"><code>OUnit2.assert_equal</code></a> the basic assert function</li><li><a href="OUnit2/index.html#val-(&gt;:::)"><code>OUnit2.(&gt;:::)</code></a> to define a list of tests</li><li><a href="OUnit2/index.html#val-(&gt;::)"><code>OUnit2.(&gt;::)</code></a> to name a test</li><li><a href="OUnit2/index.html#val-run_test_tt_main"><code>OUnit2.run_test_tt_main</code></a> to run the test suite you define</li><li><a href="OUnit2/index.html#val-bracket_tmpfile"><code>OUnit2.bracket_tmpfile</code></a> that create a temporary filename.</li><li><a href="OUnit2/index.html#val-bracket_tmpdir"><code>OUnit2.bracket_tmpdir</code></a> that create a temporary directory.</li></ul><p>File <i>test.ml</i>:</p><pre><code class="ml">open OUnit2;;

let test1 test_ctxt = assert_equal &quot;x&quot; (Foo.unity &quot;x&quot;);;

let test2 test_ctxt = assert_equal 100 (Foo.unity 100);;

(* Name the test cases and group them together *)
let suite =
&quot;suite&quot;&gt;:::
 [&quot;test1&quot;&gt;:: test1;
  &quot;test2&quot;&gt;:: test2]
;;

let () =
  run_test_tt_main suite
;;</code></pre><p>And compile the module</p><pre><code class="ml">$ ocamlfind ocamlc -o test -package oUnit -linkpkg -g foo.ml test.ml</code></pre><p>A executable named &quot;test&quot; will be created. When run it produces the following output.</p><pre><code class="ml">$ ./test
..
Ran: 2 tests in: 0.00 Seconds
OK</code></pre><p>When using <a href="OUnit2/index.html#val-run_test_tt_main"><code>OUnit2.run_test_tt_main</code></a>, a non-zero exit code signals that the test suite failed.</p><h3 id="extra-features"><a href="#extra-features" class="anchor"></a>Extra features</h3><p>OUnit supports colored output and JUnit/HTML generation. They are command line flags or environment variables that you can set before running OUnit test suites.</p><ul><li><p>Colored output:</p><ul><li>Set the environment variable <code>OUNIT_CI=true</code></li><li>Use the command line flag <code>-ci true</code></li></ul></li><li><p>JUnit generation:</p><ul><li>Set the environment variable <code>OUNIT_OUTPUT_JUNIT_FILE=fn</code></li><li>Use the command line flag <code>-output-junit-file fn</code></li></ul></li><li><p>HTML report</p><ul><li>Set the environment variable <code>OUNIT_OUTPUT_HTML_DIR=fn</code></li><li>Use the command line flag <code>-output-html-dir fn</code></li></ul></li></ul><h3 id="advanced-usage"><a href="#advanced-usage" class="anchor"></a>Advanced usage</h3><p>This section is only for advanced users who wish to uncover the power of OUnit.</p><ul class="modules"><li><a href="OUnit2/index.html"><code>OUnit2</code></a></li></ul><h4 id="error-reporting"><a href="#error-reporting" class="anchor"></a>Error reporting</h4><p>The error reporting part of OUnit is quite important. If you want to identify the failure, you should tune the display of the value and the test.</p><p>Here is a list of things you can display:</p><ul><li>name of the test: OUnit uses numbers to define path's test. But an error reporting about a failed test &quot;0:1:2&quot; is less explicit than &quot;OUnit:0:comparator:1:float_comparator:2&quot;</li><li><code>~msg</code> parameter: it allows you to define, say, which assert has failed in your test. When you have more than one assert in a test, you should provide a <code>~msg</code> to differentiate them</li><li><code>~printer</code> parameter: <a href="OUnit2/index.html#val-assert_equal"><code>OUnit2.assert_equal</code></a> allows you to define a printer for compared values. A message <code>&quot;abcd&quot; is not equal to &quot;defg&quot;</code> is better than <code>not
  equal</code></li></ul><pre><code class="ml">open OUnit2;;

let _ =
  &quot;mytest&quot;&gt;::
  (fun test_ctxt -&gt;
    assert_equal
      ~msg:&quot;int value&quot;
      ~printer:string_of_int
      1
      (Foo.unity 1))
;;</code></pre><h4 id="command-line-arguments"><a href="#command-line-arguments" class="anchor"></a>Command-line arguments</h4><p><a href="OUnit2/index.html#val-run_test_tt_main"><code>OUnit2.run_test_tt_main</code></a> already provides a set of command-line arguments to help users run only the tests they want:</p><ul><li><code>-only-test</code>: skip all the tests except this one, you can use this flag several time to select more than one test to run</li><li><code>-list-test</code>: list all the available tests and exit</li><li><code>-help</code>: display help message and exit</li></ul><p>It is also possible to add your own command-line arguments, environment variables and config file variables. You should do it if you want to define some extra arguments.</p><p>For example:</p><pre><code class="ml">open OUnit2;;

let my_program =
  Conf.make_exec &quot;my_program&quot;
;;

let test1 test_ctxt =
  assert_command (my_program test_ctxt) []
;;

let () =
  run_test_tt_main (&quot;test1&quot; &gt;:: test1)
;;</code></pre><p>The <code>Conf.make_*</code> creates a command-line argument, an environment variable and a config file variable.</p><h4 id="skip-and-todo-tests"><a href="#skip-and-todo-tests" class="anchor"></a>Skip and todo tests</h4><p>Tests are not always meaningful and can even fail because something is missing in the environment. In order to handle this, you can define a skip condition that will skip the test.</p><p>If you start by defining your tests rather than implementing the functions under test, you know that some tests will just fail. You can mark these tests as pending todo tests. This way they will be reported differently in your test suite.</p><pre><code class="ml">open OUnit2;;

let _ =
  &quot;allfuns&quot; &gt;:::
  [
    &quot;funix&quot;&gt;::
    (fun test_ctxt -&gt;
      skip_if (Sys.os_type = &quot;Win32&quot;) &quot;Don't work on Windows&quot;;
      assert_equal
        0
        (Foo.funix ()));

    &quot;fgeneric&quot;&gt;::
    (fun test_ctxt -&gt;
      todo &quot;fgeneric not implemented&quot;;
      assert_equal
        0
        (Foo.fgeneric ()));
  ]
;;</code></pre><h4 id="ounit2.threads"><a href="#ounit2.threads" class="anchor"></a>OUnit2.Threads</h4><p>This module provide thread related utilities. In particular, it provides a &quot;thread&quot; runner, that allows to run concurrently tests using OCaml threads. This should provide a good level of parallelism on Windows, for UNIX systems it is recommended to use the standard &quot;process&quot; runner.</p><p>To install the extra thread runner:</p><pre><code class="ml">let () = OUnitThreads.init ()</code></pre><ul class="modules"><li><a href="OUnitThreads/index.html"><code>OUnitThreads</code></a></li></ul><h4 id="effective-ounit"><a href="#effective-ounit" class="anchor"></a>Effective OUnit</h4><p>This section has general tips about unit testing and OUnit. It is the result of some years using OUnit in real-world applications.</p><ul><li>test everything: the more you create tests, the better chance you have to catch errors in your program early. Every submitted bug to your application should have a matching test. This is a good practice, but it is not always easy to implement.</li><li>test only what is really exported: on the long term, you have to maintain your test suite. If you test low-level functions, you'll have a lot of tests to rewrite. You should focus on creating tests for functions for which the behavior shouldn't change.</li><li>test fast: the best test suite is the one that runs after every single build. You should set your default Makefile target to run the test suite. It means that your test suite should be fast to run, typically, a 10s test suite is fine.</li><li>test long: contrary to the former tip, you should also have a complete test suite which can be very long to run. The best way to achieve both tips, is to define a command-line argument <code>-long</code> and skip the tests that are too long in your test suite according to it. When you do a release, you should run your long test suite.</li><li>family tests: when testing behavior, most of the time you call exactly the same code with different arguments. In this case <code>List.map</code> and <a href="OUnit2/index.html#val-(&gt;:::)"><code>OUnit2.(&gt;:::)</code></a> are your friends. For example:</li></ul><pre><code class="ml">open OUnit2;;

let _ =
  &quot;Family&quot;&gt;:::
  (List.map
    (fun (arg,res) -&gt;
      let title =
        Printf.sprintf &quot;%s-&gt;%s&quot; arg res
      in
        title &gt;::
        (fun test_ctxt -&gt;
          assert_equal res (Foo.unity arg)))
      [&quot;abcd&quot;, &quot;abcd&quot;;
       &quot;defg&quot;, &quot;defg&quot;;
       &quot;wxyz&quot;, &quot;wxyz&quot;])
;;</code></pre><ul><li>test failures and successes: the most obvious thing you want to test are successes, i.e. that you get the expected behavior in the normal case. But most of the errors arise in corner cases and in the code of the test itself. For example, you can have a partial application of your <a href="OUnit2/index.html#val-assert_equal"><code>OUnit2.assert_equal</code></a> and never encounter any errors, just because the <code>assert_equal</code> is not called. In this case, if you test errors as well as the &quot;happy path&quot;, you will have a notice the missing errors as well.</li><li>set up and clean your environment in the test: you should not set up and clean your test environment outside the test. Ideally, if you run no tests, the program should do nothing. This also ensures that you are always testing in a clean environment, not polluted by the result of failed tests of an earlier test run. This includes the process environment, like current working directory.</li></ul><pre><code class="ml">open OUnit2;;

let _ =
  (* We need to call a function in a particular directory *)
  &quot;change-dir-and-run&quot;&gt;::
  (fun test_ctxt -&gt;
    assert_command ~chdir:&quot;/foo/test&quot; &quot;ls&quot; [])
;;</code></pre><ul><li>separate your tests: OUnit test code should live outside the code under a directory called <i>test</i>. This allow to drop the dependency on OUnit when distributing your library/application. This also enables people to easily make a difference from what really matters (the main code) and what are only tests. It is also possible to have the tests directly in the code, like in Quickcheck-style tests.</li></ul><p>The unit testing scope is always hard to define. Unit testing should be about testing a single feature. But OUnit can also help you to test higher-level behavior, by running a full program for example. While it isn't real unit testing, you can use OUnit to do it and should not hesitate to do it.</p><p>In terms of lines of codes, a test suite can represent from 10% to 150% of the code under test. With time, your test suite will grow faster than your program/library. A good ratio is 33%.</p><h4 id="ounit2.advanced"><a href="#ounit2.advanced" class="anchor"></a>OUnit2.Advanced</h4><p>These modules should only be used when building low-level OUnit features. They allow to create your own process runner or logger.</p><p>Modules available in <code>ounit2.advanced</code>:</p><ul class="modules"><li><a href="OUnitAssert/index.html"><code>OUnitAssert</code></a></li><li><a href="OUnitBracket/index.html"><code>OUnitBracket</code></a></li><li><a href="OUnitCache/index.html"><code>OUnitCache</code></a></li><li><a href="OUnitCheckEnv/index.html"><code>OUnitCheckEnv</code></a></li><li><a href="OUnitChooser/index.html"><code>OUnitChooser</code></a></li><li><a href="OUnitConf/index.html"><code>OUnitConf</code></a></li><li><a href="OUnitCore/index.html"><code>OUnitCore</code></a></li><li><a href="OUnitDiff/index.html"><code>OUnitDiff</code></a></li><li><a href="OUnitLogger/index.html"><code>OUnitLogger</code></a></li><li><a href="OUnitLoggerCI/index.html"><code>OUnitLoggerCI</code></a></li><li><a href="OUnitLoggerHTML/index.html"><code>OUnitLoggerHTML</code></a></li><li><a href="OUnitLoggerJUnit/index.html"><code>OUnitLoggerJUnit</code></a></li><li><a href="OUnitLoggerStd/index.html"><code>OUnitLoggerStd</code></a></li><li><a href="OUnitPlugin/index.html"><code>OUnitPlugin</code></a></li><li><a href="OUnitPropList/index.html"><code>OUnitPropList</code></a></li><li><a href="OUnitResultSummary/index.html"><code>OUnitResultSummary</code></a></li><li><a href="OUnitRunner/index.html"><code>OUnitRunner</code></a></li><li><a href="OUnitRunnerProcesses/index.html"><code>OUnitRunnerProcesses</code></a></li><li><a href="OUnitShared/index.html"><code>OUnitShared</code></a></li><li><a href="OUnitState/index.html"><code>OUnitState</code></a></li><li><a href="OUnitTest/index.html"><code>OUnitTest</code></a></li><li><a href="OUnitTestData/index.html"><code>OUnitTestData</code></a></li><li><a href="OUnitUtils/index.html"><code>OUnitUtils</code></a></li></ul><dl><dt>author</dt><dd>Maas-Maarten Zeeman</dd></dl><dl><dt>author</dt><dd>Sylvain Le Gall</dd></dl></div></body></html>